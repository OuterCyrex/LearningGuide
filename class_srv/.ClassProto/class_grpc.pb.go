// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.0
// source: class.proto

package __ClassProto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Class_GetCourseList_FullMethodName       = "/class.Class/GetCourseList"
	Class_GetCourseDetail_FullMethodName     = "/class.Class/GetCourseDetail"
	Class_CreateCourse_FullMethodName        = "/class.Class/CreateCourse"
	Class_UpdateCourse_FullMethodName        = "/class.Class/UpdateCourse"
	Class_DeleteCourse_FullMethodName        = "/class.Class/DeleteCourse"
	Class_GetLessonList_FullMethodName       = "/class.Class/GetLessonList"
	Class_CreateLesson_FullMethodName        = "/class.Class/CreateLesson"
	Class_CreateLessonInBatch_FullMethodName = "/class.Class/CreateLessonInBatch"
	Class_UpdateLesson_FullMethodName        = "/class.Class/UpdateLesson"
	Class_DeleteLesson_FullMethodName        = "/class.Class/DeleteLesson"
	Class_GetLessonDetail_FullMethodName     = "/class.Class/GetLessonDetail"
	Class_DeleteLessonInBatch_FullMethodName = "/class.Class/DeleteLessonInBatch"
)

// ClassClient is the client API for Class service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClassClient interface {
	GetCourseList(ctx context.Context, in *CourseFilterRequest, opts ...grpc.CallOption) (*CourseListResponse, error)
	GetCourseDetail(ctx context.Context, in *CourseDetailRequest, opts ...grpc.CallOption) (*CourseInfoResponse, error)
	CreateCourse(ctx context.Context, in *CreateCourseRequest, opts ...grpc.CallOption) (*CreateCourseResponse, error)
	UpdateCourse(ctx context.Context, in *UpdateCourseRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteCourse(ctx context.Context, in *DeleteCourseRequest, opts ...grpc.CallOption) (*Empty, error)
	GetLessonList(ctx context.Context, in *LessonFilterRequest, opts ...grpc.CallOption) (*LessonListResponse, error)
	CreateLesson(ctx context.Context, in *CreateLessonRequest, opts ...grpc.CallOption) (*CreateLessonResponse, error)
	CreateLessonInBatch(ctx context.Context, in *CreateLessonBatchRequest, opts ...grpc.CallOption) (*CreateLessonBatchResponse, error)
	UpdateLesson(ctx context.Context, in *UpdateLessonRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteLesson(ctx context.Context, in *DeleteLessonRequest, opts ...grpc.CallOption) (*Empty, error)
	GetLessonDetail(ctx context.Context, in *LessonDetailRequest, opts ...grpc.CallOption) (*LessonInfoResponse, error)
	DeleteLessonInBatch(ctx context.Context, in *DeleteLessonInBatchRequest, opts ...grpc.CallOption) (*Empty, error)
}

type classClient struct {
	cc grpc.ClientConnInterface
}

func NewClassClient(cc grpc.ClientConnInterface) ClassClient {
	return &classClient{cc}
}

func (c *classClient) GetCourseList(ctx context.Context, in *CourseFilterRequest, opts ...grpc.CallOption) (*CourseListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CourseListResponse)
	err := c.cc.Invoke(ctx, Class_GetCourseList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) GetCourseDetail(ctx context.Context, in *CourseDetailRequest, opts ...grpc.CallOption) (*CourseInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CourseInfoResponse)
	err := c.cc.Invoke(ctx, Class_GetCourseDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) CreateCourse(ctx context.Context, in *CreateCourseRequest, opts ...grpc.CallOption) (*CreateCourseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCourseResponse)
	err := c.cc.Invoke(ctx, Class_CreateCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) UpdateCourse(ctx context.Context, in *UpdateCourseRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Class_UpdateCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) DeleteCourse(ctx context.Context, in *DeleteCourseRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Class_DeleteCourse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) GetLessonList(ctx context.Context, in *LessonFilterRequest, opts ...grpc.CallOption) (*LessonListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LessonListResponse)
	err := c.cc.Invoke(ctx, Class_GetLessonList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) CreateLesson(ctx context.Context, in *CreateLessonRequest, opts ...grpc.CallOption) (*CreateLessonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateLessonResponse)
	err := c.cc.Invoke(ctx, Class_CreateLesson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) CreateLessonInBatch(ctx context.Context, in *CreateLessonBatchRequest, opts ...grpc.CallOption) (*CreateLessonBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateLessonBatchResponse)
	err := c.cc.Invoke(ctx, Class_CreateLessonInBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) UpdateLesson(ctx context.Context, in *UpdateLessonRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Class_UpdateLesson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) DeleteLesson(ctx context.Context, in *DeleteLessonRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Class_DeleteLesson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) GetLessonDetail(ctx context.Context, in *LessonDetailRequest, opts ...grpc.CallOption) (*LessonInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LessonInfoResponse)
	err := c.cc.Invoke(ctx, Class_GetLessonDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *classClient) DeleteLessonInBatch(ctx context.Context, in *DeleteLessonInBatchRequest, opts ...grpc.CallOption) (*Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Empty)
	err := c.cc.Invoke(ctx, Class_DeleteLessonInBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClassServer is the server API for Class service.
// All implementations must embed UnimplementedClassServer
// for forward compatibility.
type ClassServer interface {
	GetCourseList(context.Context, *CourseFilterRequest) (*CourseListResponse, error)
	GetCourseDetail(context.Context, *CourseDetailRequest) (*CourseInfoResponse, error)
	CreateCourse(context.Context, *CreateCourseRequest) (*CreateCourseResponse, error)
	UpdateCourse(context.Context, *UpdateCourseRequest) (*Empty, error)
	DeleteCourse(context.Context, *DeleteCourseRequest) (*Empty, error)
	GetLessonList(context.Context, *LessonFilterRequest) (*LessonListResponse, error)
	CreateLesson(context.Context, *CreateLessonRequest) (*CreateLessonResponse, error)
	CreateLessonInBatch(context.Context, *CreateLessonBatchRequest) (*CreateLessonBatchResponse, error)
	UpdateLesson(context.Context, *UpdateLessonRequest) (*Empty, error)
	DeleteLesson(context.Context, *DeleteLessonRequest) (*Empty, error)
	GetLessonDetail(context.Context, *LessonDetailRequest) (*LessonInfoResponse, error)
	DeleteLessonInBatch(context.Context, *DeleteLessonInBatchRequest) (*Empty, error)
	mustEmbedUnimplementedClassServer()
}

// UnimplementedClassServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClassServer struct{}

func (UnimplementedClassServer) GetCourseList(context.Context, *CourseFilterRequest) (*CourseListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCourseList not implemented")
}
func (UnimplementedClassServer) GetCourseDetail(context.Context, *CourseDetailRequest) (*CourseInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCourseDetail not implemented")
}
func (UnimplementedClassServer) CreateCourse(context.Context, *CreateCourseRequest) (*CreateCourseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCourse not implemented")
}
func (UnimplementedClassServer) UpdateCourse(context.Context, *UpdateCourseRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCourse not implemented")
}
func (UnimplementedClassServer) DeleteCourse(context.Context, *DeleteCourseRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCourse not implemented")
}
func (UnimplementedClassServer) GetLessonList(context.Context, *LessonFilterRequest) (*LessonListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLessonList not implemented")
}
func (UnimplementedClassServer) CreateLesson(context.Context, *CreateLessonRequest) (*CreateLessonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLesson not implemented")
}
func (UnimplementedClassServer) CreateLessonInBatch(context.Context, *CreateLessonBatchRequest) (*CreateLessonBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLessonInBatch not implemented")
}
func (UnimplementedClassServer) UpdateLesson(context.Context, *UpdateLessonRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLesson not implemented")
}
func (UnimplementedClassServer) DeleteLesson(context.Context, *DeleteLessonRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLesson not implemented")
}
func (UnimplementedClassServer) GetLessonDetail(context.Context, *LessonDetailRequest) (*LessonInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLessonDetail not implemented")
}
func (UnimplementedClassServer) DeleteLessonInBatch(context.Context, *DeleteLessonInBatchRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLessonInBatch not implemented")
}
func (UnimplementedClassServer) mustEmbedUnimplementedClassServer() {}
func (UnimplementedClassServer) testEmbeddedByValue()               {}

// UnsafeClassServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClassServer will
// result in compilation errors.
type UnsafeClassServer interface {
	mustEmbedUnimplementedClassServer()
}

func RegisterClassServer(s grpc.ServiceRegistrar, srv ClassServer) {
	// If the following call pancis, it indicates UnimplementedClassServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Class_ServiceDesc, srv)
}

func _Class_GetCourseList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CourseFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).GetCourseList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_GetCourseList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).GetCourseList(ctx, req.(*CourseFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_GetCourseDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CourseDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).GetCourseDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_GetCourseDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).GetCourseDetail(ctx, req.(*CourseDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_CreateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).CreateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_CreateCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).CreateCourse(ctx, req.(*CreateCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_UpdateCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).UpdateCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_UpdateCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).UpdateCourse(ctx, req.(*UpdateCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_DeleteCourse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCourseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).DeleteCourse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_DeleteCourse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).DeleteCourse(ctx, req.(*DeleteCourseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_GetLessonList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LessonFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).GetLessonList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_GetLessonList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).GetLessonList(ctx, req.(*LessonFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_CreateLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).CreateLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_CreateLesson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).CreateLesson(ctx, req.(*CreateLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_CreateLessonInBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLessonBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).CreateLessonInBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_CreateLessonInBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).CreateLessonInBatch(ctx, req.(*CreateLessonBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_UpdateLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).UpdateLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_UpdateLesson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).UpdateLesson(ctx, req.(*UpdateLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_DeleteLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).DeleteLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_DeleteLesson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).DeleteLesson(ctx, req.(*DeleteLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_GetLessonDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LessonDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).GetLessonDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_GetLessonDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).GetLessonDetail(ctx, req.(*LessonDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Class_DeleteLessonInBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLessonInBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClassServer).DeleteLessonInBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Class_DeleteLessonInBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClassServer).DeleteLessonInBatch(ctx, req.(*DeleteLessonInBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Class_ServiceDesc is the grpc.ServiceDesc for Class service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Class_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "class.Class",
	HandlerType: (*ClassServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCourseList",
			Handler:    _Class_GetCourseList_Handler,
		},
		{
			MethodName: "GetCourseDetail",
			Handler:    _Class_GetCourseDetail_Handler,
		},
		{
			MethodName: "CreateCourse",
			Handler:    _Class_CreateCourse_Handler,
		},
		{
			MethodName: "UpdateCourse",
			Handler:    _Class_UpdateCourse_Handler,
		},
		{
			MethodName: "DeleteCourse",
			Handler:    _Class_DeleteCourse_Handler,
		},
		{
			MethodName: "GetLessonList",
			Handler:    _Class_GetLessonList_Handler,
		},
		{
			MethodName: "CreateLesson",
			Handler:    _Class_CreateLesson_Handler,
		},
		{
			MethodName: "CreateLessonInBatch",
			Handler:    _Class_CreateLessonInBatch_Handler,
		},
		{
			MethodName: "UpdateLesson",
			Handler:    _Class_UpdateLesson_Handler,
		},
		{
			MethodName: "DeleteLesson",
			Handler:    _Class_DeleteLesson_Handler,
		},
		{
			MethodName: "GetLessonDetail",
			Handler:    _Class_GetLessonDetail_Handler,
		},
		{
			MethodName: "DeleteLessonInBatch",
			Handler:    _Class_DeleteLessonInBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "class.proto",
}
